use anyhow::Result;
use chrono::{DateTime, Utc};
use dashmap::DashMap;
use futures_util::{SinkExt, StreamExt};
use log::{error, info};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use std::sync::Arc;
use tokio::net::{TcpListener, TcpStream};
use tokio::sync::mpsc;
use tokio_tungstenite::{accept_async, tungstenite::Message, WebSocketStream};
use uuid::Uuid;

// Типы данных для сервера сигналинга
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Пользователь {
    pub id: String,
    pub имя: String,
    pub телеграм_id: Option<u64>,
    pub аватар: Option<String>,
    pub подключен: bool,
    pub в_комнате: Option<String>,
    pub микрофон_включен: bool,
    pub говорит: bool,
    pub последняя_активность: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Комната {
    pub id: String,
    pub название: String,
    pub создатель: String,
    pub участники: Vec<String>, // ID пользователей
    pub максимум_участников: usize,
    pub создана: DateTime<Utc>,
    pub активна: bool,
    pub приватная: bool,
    pub пароль: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "тип")]
pub enum СообщениеВебСокета {
    #[serde(rename = "присоединиться")]
    Присоединиться {
        пользователь: Пользователь,
    },
    #[serde(rename = "покинуть")]
    Покинуть {
        пользователь_id: String,
    },
    #[serde(rename = "создать-комнату")]
    СоздатьКомнату {
        название: String,
        создатель: String,
        максимум_участников: usize,
        приватная: bool,
        пароль: Option<String>,
    },
    #[serde(rename = "присоединиться-к-комнате")]
    ПрисоединитьсяККомнате {
        комната_id: String,
        пользователь_id: String,
        пароль: Option<String>,
    },
    #[serde(rename = "покинуть-комнату")]
    ПокинутьКомнату {
        комната_id: String,
        пользователь_id: String,
    },
    #[serde(rename = "webrtc-signal")]
    WebRTCСигнал {
        от: String,
        к: String,
        комната: String,
        данные: serde_json::Value,
    },
    #[serde(rename = "микрофон-переключен")]
    МикрофонПереключен {
        пользователь_id: String,
        комната_id: String,
        включен: bool,
    },
    #[serde(rename = "говорит")]
    Говорит {
        пользователь_id: String,
        комната_id: String,
        говорит: bool,
    },
    #[serde(rename = "получить-комнаты")]
    ПолучитьКомнаты,
    #[serde(rename = "получить-пользователей-комнаты")]
    ПолучитьПользователейКомнаты {
        комната_id: String,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "тип")]
pub enum ОтветСервера {
    #[serde(rename = "пользователи-обновлены")]
    ПользователиОбновлены {
        пользователи: Vec<Пользователь>,
    },
    #[serde(rename = "комнаты-обновлены")]
    КомнатыОбновлены {
        комнаты: Vec<Комната>,
    },
    #[serde(rename = "участники-комнаты-обновлены")]
    УчастникиКомнатыОбновлены {
        комната_id: String,
        участники: Vec<Пользователь>,
    },
    #[serde(rename = "комната-создана")]
    КомнатаСоздана {
        комната: Комната,
    },
    #[serde(rename = "присоединился-к-комнате")]
    ПрисоединилсяККомнате {
        комната: Комната,
        пользователь: Пользователь,
    },
    #[serde(rename = "покинул-комнату")]
    ПокинулКомнату {
        комната_id: String,
        пользователь_id: String,
    },
    #[serde(rename = "webrtc-signal")]
    WebRTCСигнал {
        от: String,
        к: String,
        комната: String,
        данные: serde_json::Value,
    },
    #[serde(rename = "микрофон-переключен")]
    МикрофонПереключен {
        пользователь_id: String,
        комната_id: String,
        включен: bool,
    },
    #[serde(rename = "говорит")]
    Говорит {
        пользователь_id: String,
        комната_id: String,
        говорит: bool,
    },
    #[serde(rename = "ошибка")]
    Ошибка {
        сообщение: String,
    },
}

type WebSocketMap = Arc<DashMap<String, mpsc::UnboundedSender<Message>>>;
type ПользователиMap = Arc<DashMap<String, Пользователь>>;
type КомнатыMap = Arc<DashMap<String, Комната>>;

#[derive(Clone)]
pub struct СерверСостояние {
    pub websockets: WebSocketMap,
    pub пользователи: ПользователиMap,
    pub комнаты: КомнатыMap,
}

impl СерверСостояние {
    pub fn new() -> Self {
        Self {
            websockets: Arc::new(DashMap::new()),
            пользователи: Arc::new(DashMap::new()),
            комнаты: Arc::new(DashMap::new()),
        }
    }

    // Отправка сообщения пользователю
    pub async fn отправить_пользователю(&self, пользователь_id: &str, сообщение: ОтветСервера) {
        if let Some(sender) = self.websockets.get(пользователь_id) {
            let json = match serde_json::to_string(&сообщение) {
                Ok(json) => json,
                Err(e) => {
                    error!("Ошибка сериализации сообщения: {}", e);
                    return;
                }
            };

            if let Err(e) = sender.send(Message::Text(json)) {
                error!("Ошибка отправки сообщения пользователю {}: {}", пользователь_id, e);
                self.websockets.remove(пользователь_id);
            }
        }
    }

    // Отправка сообщения всем участникам комнаты
    pub async fn отправить_в_комнату(&self, комната_id: &str, сообщение: ОтветСервера, исключить: Option<&str>) {
        if let Some(комната) = self.комнаты.get(комната_id) {
            for участник_id in &комната.участники {
                if Some(участник_id.as_str()) != исключить {
                    self.отправить_пользователю(участник_id, сообщение.clone()).await;
                }
            }
        }
    }

    // Отправка сообщения всем подключенным пользователям
    pub async fn рассылка(&self, сообщение: ОтветСервера) {
        for пользователь_id in self.websockets.iter() {
            self.отправить_пользователю(пользователь_id.key(), сообщение.clone()).await;
        }
    }

    // Создание новой комнаты
    pub fn создать_комнату(&self, название: String, создатель: String, максимум_участников: usize, приватная: bool, пароль: Option<String>) -> Result<Комната> {
        let комната = Комната {
            id: Uuid::new_v4().to_string(),
            название,
            создатель: создатель.clone(),
            участники: vec![создатель],
            максимум_участников,
            создана: Utc::now(),
            активна: true,
            приватная,
            пароль,
        };

        self.комнаты.insert(комната.id.clone(), комната.clone());
        
        // Добавляем создателя в комнату
        if let Some(mut пользователь) = self.пользователи.get_mut(&комната.создатель) {
            пользователь.в_комнате = Some(комната.id.clone());
        }

        Ok(комната)
    }

    // Присоединение к комнате
    pub fn присоединиться_к_комнате(&self, комната_id: &str, пользователь_id: &str, пароль: Option<String>) -> Result<()> {
        let mut комната = self.комнаты.get_mut(комната_id)
            .ok_or_else(|| anyhow::anyhow!("Комната не найдена"))?;

        if комната.участники.len() >= комната.максимум_участников {
            return Err(anyhow::anyhow!("Комната переполнена"));
        }

        if комната.приватная && комната.пароль != пароль {
            return Err(anyhow::anyhow!("Неверный пароль"));
        }

        if !комната.участники.contains(&пользователь_id.to_string()) {
            комната.участники.push(пользователь_id.to_string());
        }

        // Обновляем пользователя
        if let Some(mut пользователь) = self.пользователи.get_mut(пользователь_id) {
            пользователь.в_комнате = Some(комната_id.to_string());
        }

        Ok(())
    }

    // Покинуть комнату
    pub fn покинуть_комнату(&self, комната_id: &str, пользователь_id: &str) {
        if let Some(mut комната) = self.комнаты.get_mut(комната_id) {
            комната.участники.retain(|id| id != пользователь_id);
            
            // Если комната пуста, удаляем её
            if комната.участники.is_empty() {
                drop(комната);
                self.комнаты.remove(комната_id);
            }
        }

        // Обновляем пользователя
        if let Some(mut пользователь) = self.пользователи.get_mut(пользователь_id) {
            пользователь.в_комнате = None;
        }
    }

    // Получить список комнат
    pub fn получить_комнаты(&self) -> Vec<Комната> {
        self.комнаты.iter()
            .filter(|entry| entry.активна)
            .map(|entry| entry.clone())
            .collect()
    }

    // Получить участников комнаты
    pub fn получить_участников_комнаты(&self, комната_id: &str) -> Vec<Пользователь> {
        if let Some(комната) = self.комнаты.get(комната_id) {
            комната.участники.iter()
                .filter_map(|id| self.пользователи.get(id).map(|u| u.clone()))
                .collect()
        } else {
            Vec::new()
        }
    }
}

async fn обработать_соединение(
    ws_stream: WebSocketStream<TcpStream>,
    addr: SocketAddr,
    состояние: СерверСостояние,
) {
    info!("Новое WebSocket соединение: {}", addr);
    
    let (mut ws_sender, mut ws_receiver) = ws_stream.split();
    let пользователь_id = Uuid::new_v4().to_string();
    
    // Создаем канал для отправки сообщений
    let (tx, mut rx) = mpsc::unbounded_channel();
    состояние.websockets.insert(пользователь_id.clone(), tx);

    // Задача для отправки сообщений
    let send_task = tokio::spawn(async move {
        while let Some(msg) = rx.recv().await {
            if ws_sender.send(msg).await.is_err() {
                break;
            }
        }
    });

    // Основной цикл обработки входящих сообщений
    while let Some(msg) = ws_receiver.next().await {
        match msg {
            Ok(Message::Text(text)) => {
                if let Err(e) = обработать_сообщение(&text, &пользователь_id, &состояние).await {
                    error!("Ошибка обработки сообщения: {}", e);
                    состояние.отправить_пользователю(&пользователь_id, ОтветСервера::Ошибка {
                        сообщение: e.to_string(),
                    }).await;
                }
            }
            Ok(Message::Close(_)) => {
                info!("Соединение закрыто: {}", addr);
                break;
            }
            Err(e) => {
                error!("Ошибка WebSocket: {}", e);
                break;
            }
            _ => {}
        }
    }

    // Отменяем задачу отправки
    send_task.abort();

    // Очистка при отключении
    состояние.websockets.remove(&пользователь_id);
    if let Some(пользователь) = состояние.пользователи.get(&пользователь_id) {
        if let Some(комната_id) = &пользователь.в_комнате {
            состояние.покинуть_комнату(комната_id, &пользователь_id);
            
            // Уведомляем участников комнаты
            состояние.отправить_в_комнату(комната_id, ОтветСервера::ПокинулКомнату {
                комната_id: комната_id.clone(),
                пользователь_id: пользователь_id.clone(),
            }, None).await;
            
            // Обновляем список участников
            let участники = состояние.получить_участников_комнаты(комната_id);
            состояние.отправить_в_комнату(комната_id, ОтветСервера::УчастникиКомнатыОбновлены {
                комната_id: комната_id.clone(),
                участники,
            }, None).await;
        }
    }
    состояние.пользователи.remove(&пользователь_id);
    
    info!("Пользователь {} отключился", пользователь_id);
}

async fn обработать_сообщение(
    text: &str,
    пользователь_id: &str,
    состояние: &СерверСостояние,
) -> Result<()> {
    // Пытаемся парсить как общее JSON сообщение
    let json: serde_json::Value = serde_json::from_str(text)?;
    
    // Получаем тип сообщения
    let message_type = json.get("тип")
        .and_then(|v| v.as_str())
        .unwrap_or("unknown");
    
    match message_type {
        "подключение" => {
            if let Some(данные) = json.get("данные") {
                let имя = данные.get("имя").and_then(|v| v.as_str()).unwrap_or("Гость").to_string();
                let телеграм_id = данные.get("телеграм_id").and_then(|v| v.as_u64());
                
                let пользователь = Пользователь {
                    id: пользователь_id.to_string(),
                    имя,
                    телеграм_id,
                    аватар: None,
                    подключен: true,
                    в_комнате: None,
                    микрофон_включен: true,
                    говорит: false,
                    последняя_активность: Utc::now(),
                };
                
                info!("Пользователь {} присоединился", пользователь.имя);
                состояние.пользователи.insert(пользователь_id.to_string(), пользователь.clone());
                
                // Отправляем список комнат новому пользователю
                let комнаты = состояние.получить_комнаты();
                состояние.отправить_пользователю(пользователь_id, ОтветСервера::КомнатыОбновлены { комнаты }).await;
            }
        }
        
        _ => {
            // Пытаемся парсить как структурированное сообщение
            let сообщение: СообщениеВебСокета = serde_json::from_str(text)?;
    
    match сообщение {
        СообщениеВебСокета::Присоединиться { пользователь } => {
            info!("Пользователь {} присоединился", пользователь.имя);
            состояние.пользователи.insert(пользователь_id.to_string(), пользователь.clone());
            
            // Отправляем список всех пользователей
            let пользователи: Vec<Пользователь> = состояние.пользователи.iter()
                .map(|entry| entry.clone())
                .collect();
            
            состояние.рассылка(ОтветСервера::ПользователиОбновлены { пользователи }).await;
            
            // Отправляем список комнат новому пользователю
            let комнаты = состояние.получить_комнаты();
            состояние.отправить_пользователю(пользователь_id, ОтветСервера::КомнатыОбновлены { комнаты }).await;
        }

        СообщениеВебСокета::СоздатьКомнату { название, создатель, максимум_участников, приватная, пароль } => {
            match состояние.создать_комнату(название, создатель, максимум_участников, приватная, пароль) {
                Ok(комната) => {
                    info!("Создана комната: {}", комната.название);
                    
                    // Уведомляем всех о новой комнате
                    состояние.рассылка(ОтветСервера::КомнатаСоздана { комната: комната.clone() }).await;
                    
                    // Отправляем создателю подтверждение присоединения
                    if let Some(пользователь) = состояние.пользователи.get(пользователь_id) {
                        состояние.отправить_пользователю(пользователь_id, ОтветСервера::ПрисоединилсяККомнате {
                            комната: комната.clone(),
                            пользователь: пользователь.clone(),
                        }).await;
                    }
                }
                Err(e) => {
                    error!("Ошибка создания комнаты: {}", e);
                    состояние.отправить_пользователю(пользователь_id, ОтветСервера::Ошибка {
                        сообщение: format!("Не удалось создать комнату: {}", e),
                    }).await;
                }
            }
        }

        СообщениеВебСокета::ПрисоединитьсяККомнате { комната_id, пользователь_id: user_id, пароль } => {
            match состояние.присоединиться_к_комнате(&комната_id, &user_id, пароль) {
                Ok(_) => {
                    if let (Some(комната), Some(пользователь)) = (
                        состояние.комнаты.get(&комната_id),
                        состояние.пользователи.get(&user_id)
                    ) {
                        info!("Пользователь {} присоединился к комнате {}", пользователь.имя, комната.название);
                        
                        // Подтверждение присоединения
                        состояние.отправить_пользователю(&user_id, ОтветСервера::ПрисоединилсяККомнате {
                            комната: комната.clone(),
                            пользователь: пользователь.clone(),
                        }).await;
                        
                        // Обновляем список участников для всех в комнате
                        let участники = состояние.получить_участников_комнаты(&комната_id);
                        состояние.отправить_в_комнату(&комната_id, ОтветСервера::УчастникиКомнатыОбновлены {
                            комната_id: комната_id.clone(),
                            участники,
                        }, None).await;
                    }
                }
                Err(e) => {
                    error!("Ошибка присоединения к комнате: {}", e);
                    состояние.отправить_пользователю(пользователь_id, ОтветСервера::Ошибка {
                        сообщение: format!("Не удалось присоединиться к комнате: {}", e),
                    }).await;
                }
            }
        }

        СообщениеВебСокета::ПокинутьКомнату { комната_id, пользователь_id: user_id } => {
            состояние.покинуть_комнату(&комната_id, &user_id);
            
            // Уведомляем участников комнаты
            состояние.отправить_в_комнату(&комната_id, ОтветСервера::ПокинулКомнату {
                комната_id: комната_id.clone(),
                пользователь_id: user_id.clone(),
            }, Some(&user_id)).await;
            
            // Обновляем список участников
            let участники = состояние.получить_участников_комнаты(&комната_id);
            состояние.отправить_в_комнату(&комната_id, ОтветСервера::УчастникиКомнатыОбновлены {
                комната_id: комната_id.clone(),
                участники,
            }, None).await;
        }

        СообщениеВебСокета::WebRTCСигнал { от, к, комната, данные } => {
            // Пересылаем WebRTC сигнал получателю
            состояние.отправить_пользователю(&к, ОтветСервера::WebRTCСигнал {
                от: от.clone(),
                к: к.clone(),
                комната: комната.clone(),
                данные,
            }).await;
        }

        СообщениеВебСокета::МикрофонПереключен { пользователь_id: user_id, комната_id, включен } => {
            // Обновляем состояние микрофона пользователя
            if let Some(mut пользователь) = состояние.пользователи.get_mut(&user_id) {
                пользователь.микрофон_включен = включен;
            }
            
            // Уведомляем участников комнаты
            состояние.отправить_в_комнату(&комната_id, ОтветСервера::МикрофонПереключен {
                пользователь_id: user_id.clone(),
                комната_id: комната_id.clone(),
                включен,
            }, None).await;
        }

        СообщениеВебСокета::Говорит { пользователь_id: user_id, комната_id, говорит } => {
            // Обновляем состояние речи пользователя
            if let Some(mut пользователь) = состояние.пользователи.get_mut(&user_id) {
                пользователь.говорит = говорит;
            }
            
            // Уведомляем участников комнаты
            состояние.отправить_в_комнату(&комната_id, ОтветСервера::Говорит {
                пользователь_id: user_id.clone(),
                комната_id: комната_id.clone(),
                говорит,
            }, None).await;
        }

        СообщениеВебСокета::ПолучитьКомнаты => {
            let комнаты = состояние.получить_комнаты();
            состояние.отправить_пользователю(пользователь_id, ОтветСервера::КомнатыОбновлены { комнаты }).await;
        }

        СообщениеВебСокета::ПолучитьПользователейКомнаты { комната_id } => {
            let участники = состояние.получить_участников_комнаты(&комната_id);
            состояние.отправить_пользователю(пользователь_id, ОтветСервера::УчастникиКомнатыОбновлены {
                комната_id,
                участники,
            }).await;
        }

        _ => {}
    }
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    env_logger::init();
    
    let состояние = СерверСостояние::new();
    let addr = "0.0.0.0:8080";
    let listener = TcpListener::bind(&addr).await?;
    
    info!("WebSocket сервер запущен на {}", addr);
    
    while let Ok((stream, addr)) = listener.accept().await {
        let состояние = состояние.clone();
        
        tokio::spawn(async move {
            match accept_async(stream).await {
                Ok(ws_stream) => {
                    обработать_соединение(ws_stream, addr, состояние).await;
                }
                Err(e) => {
                    error!("Ошибка WebSocket handshake: {}", e);
                }
            }
        });
    }
    
    Ok(())
}